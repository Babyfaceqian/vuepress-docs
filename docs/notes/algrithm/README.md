## 不同数据结构在算法中的应用

### 数组

### 链表

链表的特点如下：

1. 链表是一种线性数据结构，它的元素按照线性顺序排列。
2. 链表的每个元素都包含一个数据域和一个指针域，指针域指向下一个元素的地址。
3. 链表的主要应用场景是实现栈、队列、哈希表等数据结构。
4. 链表的优点是插入和删除元素的时间复杂度为 O(1)，缺点是访问元素的时间复杂度为 O(n)。

常见算法题场景：

1. 反转链表，用三个指针，分别指向当前节点、前一个节点、后一个节点，然后依次遍历链表，将当前节点的指针指向前一个节点，然后依次向后移动指针。
2. 合并两个有序链表，用一个指针指向两个链表中较小的节点，然后依次向后移动指针。

### 栈

栈是一种数据结构，主要有以下几个特点：

1. 栈是一种线性数据结构，它的元素按照后进先出的顺序排列。
2. 栈的操作只有两种：入栈和出栈。
3. 栈的主要应用场景是函数调用栈、表达式求值、括号匹配等。

常见算法题场景：

1.  有效的括号, 用栈存储左括号，遇到右括号就出栈，判断是否匹配。

### 队列

### 树

### 二叉树

二叉树的特点如下：

1. 二叉树是一种树形数据结构，它的每个节点最多有两个子节点。
2. 二叉树的子节点分为左子节点和右子节点。
3. 二叉树的主要应用场景是实现二叉搜索树、堆、哈夫曼树等数据结构。

常见算法题场景：

1. 二叉树的前序遍历，用栈存储根节点，然后依次遍历左子树和右子树。
2. 二叉树的中序遍历，用栈存储根节点，然后依次遍历左子树和右子树。
3. 二叉树的后序遍历，用栈存储根节点，然后依次遍历左子树和右子树。
4. 二叉树的层序遍历，用队列存储根节点，然后依次遍历左子树和右子树。

### 图

### 哈希表

在 JavaScript 中，哈希表的实现有两种，一种是对象，一种是 Map 类。主要有以下几点区别：

1. 键的类型：对象的键只能是字符串或符号类型，而 Map 类的键可以是任意类型，包括对象、函数、数组等。
2. 键的顺序：对象的键是无序的，而 Map 类的键是有序的，按照插入的顺序排列。

还有个特殊的 WeakMap 类，只接受对象或非全局注册的 Symbol 作为键。它的键是弱引用，也就是说，如果一个键所对应的对象没有其他引用，那么这个键就会被自动回收。

哈希表的主要特点是:

1. 哈希表是一种数据结构，它可以将任意类型的数据映射到一个固定长度的值（hash 值），作为数组的索引，并使用数组存储值。
2. 哈希表的查找、插入和删除操作的时间复杂度都是 O(1)。

利用哈希表查找、插入、删除复杂度低的优势，我们可以在算法中使用哈希表来优化时间复杂度。比如以下算法题场景：

1. 两数之和，用哈希表存储数组中的值和索引，然后遍历数组，查找哈希表中是否存在 target - nums[i] 的值。
2. 有效的括号，用哈希表存储左括号和右括号的对应关系，然后遍历字符串，判断是否是左括号，如果是左括号，就入栈，如果是右括号，就判断栈顶元素是否是对应的左括号，如果是，就出栈，否则返回 false。
3. 删除有序数组中的重复项，用哈希表存储数组中的值和索引，然后遍历数组，查找哈希表中是否存在 nums[i] 的值，如果存在，就删除该元素，否则将该元素加入哈希表。

### 堆

## 不同流程控制在算法中的应用

### 递归

递归的特点如下：

1. 递归是一种函数调用自身的方式。
2. 递归函数必须有一个终止条件，否则会无限递归，导致栈溢出。
3. 递归函数的执行过程是一个栈的过程，每次调用函数都会将函数的参数、局部变量、返回地址等信息压入栈中，当函数返回时，这些信息会被弹出栈。

在遇到递归问题时，我们可以先考虑递归的终止条件，然后考虑递归的过程。

在遇到递归性能问题时，如递归深度太深，可以考虑使用缓存的方式，存储计算过的结果，避免重复计算。

场景：

1. 爬楼梯，每次可以爬 1 或 2 步，求爬到第 n 阶楼梯的方法数。

### 迭代

## 常用算法逻辑

### 双指针

#### 快慢指针

快慢指针是一种经典的双指针算法，通过两个指针以不同速度遍历数据结构（如链表、数组）来解决问题，主要应用于以下场景：
一、链表类问题

1. 环形链表检测
   快指针每次移动两步，慢指针移动一步。若存在环，快指针最终会追上慢指针；若无环，快指针会先到达链表尾部。时间复杂度为 O(n)，空间复杂度 O(1)
2. 寻找链表的中间节点
   快指针以两倍速移动，当快指针到达尾部时，慢指针正好位于中点。需区分链表长度的奇偶性，偶数时可选上中位数或下中位数。
3. 回文链表判断
   先用快慢指针找到中间节点，然后反转后半部分链表，再与前半部分逐节点比较。此方法无需额外空间，时间复杂度 O(n)。
4. 删除倒数第 k 个节点
   快指针先移动 k 步，随后快慢指针同步移动。当快指针到达末尾时，慢指针指向倒数第 k 个节点的前驱节点，便于删除操作 。
   二、数组类问题
5. 原地修改数组（如去重、删除元素）
   快指针遍历数组，慢指针标记有效位置。例如在有序数组中删除重复项时，仅当快指针发现新元素时才移动慢指针并更新值，时间复杂度 O(n) 。
6. 滑动窗口问题
   快指针扩展窗口，慢指针根据条件收缩窗口，常用于寻找满足条件的子数组或子字符串（如最小覆盖子串）。

三、其他场景

1. 快乐数检测
   将数字按位平方和视为链表节点，快慢指针用于检测是否存在循环（即是否进入无限循环）。若相遇点为 1 则是快乐数，否则不是 7 。
2. 寻找链表的交点
   结合快慢指针与链表长度差，调整起始位置后同步遍历，找到两个链表的相交节点。

优势总结

1. 时间复杂度低 ：多数问题可在线性时间内解决（O(n)）。
2. 空间复杂度优 ：通常无需额外存储（O(1)），适合内存敏感场景。
3. 灵活性强 ：通过调整指针步长（如快指针移动 2 步或 k 步）可适应不同需求 。

### 滑动窗口

### 二分查找

1. 搜索插入位置, 找到第一个大于等于 target 的位置

### 深度优先搜索

### 广度优先搜索

### 贪心算法

### 动态规划

动态规划（dynamic programming）是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。

核心点：

1. 最优子结构性质：问题的最优解包含子问题的最优解。
2. 重叠子问题性质：子问题的解被重复计算。

步骤：

1. 定义状态：将问题分解为一系列子问题，并定义每个子问题的最优解。
2. 定义状态转移方程：根据子问题的解，定义从一个子问题到另一个子问题的转移方式。
3. 初始化：确定初始状态的值。
4. 计算最优解：按照状态转移方程，计算出每个子问题的最优解。
5. 构造最优解：根据子问题的最优解，构造出原问题的最优解。

### 回溯算法
